{-# LANGUAGE NoMonomorphismRestriction #-}
module BFPG where

import Data.Monoid
import SlideTypes
import Control.Wire
import SDLStuff
import qualified Graphics.UI.SDL as SDL
import Data.Fixed
import Prelude hiding ((.))
import Text.Printf (printf)
import Data.List (intercalate)
import qualified Control.Monad as M

bfpg codeFont tagFont = intro ++ gameLoops ++ introToWires ++ buildingSky ++ movingObjects ++ problems
  where intro = [
                 Subtitled "Programming Games in Haskell" "Nick Partridge - @nkpart - nkpart@gmail.com"
               , bulleted "Bio" [ "Not a games programmer"
                                , "Written exactly 2 apps with this technology"
                                , "Have no idea what FRP is"
                                ]
               , bulleted "The Technology" [ "Haskell"
                                           , "SDL - inputs. drawing rectangles, images and text"
                                           , "Netwire - FRP(*). Values/functions that change over time"
                                           ]
               , bulleted "Why?" [ "Ocharles is super rad"
                                 , "CampJS is also super rad"
                                 , "DEMO"]
               , Bulleted "Topics" [ "Game Loops"
                                   , "Intro to Wires"
                                   , "Building the Sky"
                                   , "An Object"
                                   , "Problems/Gotchas"
                                   ]
                <> Raw (pure $ \window -> do
                       M.forM_ (zip "⟳→★△☹" [0..]) $ \(t,idx) -> do
                         drawString window (255,255,255) (t:[]) tagFont (500, 130 + (idx * 80))
                       return ())
               ]

        gameLoops = tagAll "⟳" [ Title "Game Loops"]

        introToWires = tagAll "→" [ Title "Intro to Wires"]

        buildingSky = tagAll "★" [ Title "Building Sky"
                                 , Raw (fastTime >>> arr (\t window -> drawString window (255,255,255) (floatString t) codeFont (50, 100)))
                                 <> ShowCode "time :: Wire e m a Time"
                                 , Raw (fastTimeFrom 17 >>^ (\t -> t `mod'` 24) >>> arr (\t window -> drawString window (255,255,255) (floatString t) codeFont (50, 100)))
                                 <> ShowCode "timeFrom 17 >>^ (\\t -> t `mod'` 24))"
                                 ]

        movingObjects = tagAll "△" [ Title "Moving Objects"
                                   ]

        problems = tagAll "☹" [ Title "Problems/Gotchas"
                              ]
        
       -- , Title "Three"
       -- , Title "EXAMPLES"
       -- , Title "The real fun in games comes from reating to Events -- user inputs, network events, events generated by the sim"
       -- -- TODO: hold "" vs pure ""
       -- , GenText (fmap (:[]) $ hold ' ' (periodically 0.5 >>> cycleW "bfpg"))
       --   <> ShowCode "periodically 0.5 >>> cycleW \"bfpg\""
       -- , GenText (fmap (:[]) $ hold ' ' (cycleW "bfpg" >>> periodically 0.5)) -- example of preceding operator vs proceding
       --   <> ShowCode "cycleW \"bfpg\" >>> periodically 0.5"
       -- , Raw (fastTimeFrom (17 / timeScale) >>^ (\t -> t `mod'` 24) >>> arr (\t window -> drawString window (255,255,255) (floatString t) codeFont (50, 100)))
       --   <> ShowCode "timeFrom 17 >>^ (\\t -> t `mod'` 24))"

fastTime = time >>^ (* timeScale)
fastTimeFrom x = timeFrom (x / timeScale) >>^ (* timeScale)

floatString t = printf "%.2f" t

-- data Wire' a b = Wire' (f :: Time -> a -> (Either Error b, Wire' a b) )
-- data GameState = GameState Int
-- data Events

-- gameLoopWire :: Wire Events GameState
-- gameLoopWire = mkState (GameState 0) f
--   where f time (events, state) = let nextState = gameUpdate time events state
--                                   in (Right nextState, nextState)
-- 
-- fff theWire theSession = do
--   events <- pollEvents
--   (gameState, newWire, newSession) <- stepSession theWire theSession events
--   render gameState
--   fff newWire newSession
-- 
-- main = do
--     session <- clockSession
--     fff gameLoopWire session


-- gameUpdate :: Time -> Events -> GameState -> GameState

-- {- 
-- $state = ...
-- 
-- while true do
--    inputs = getEvents
--    updateWorld(inputs)
--    render()
-- end
-- 
-- - }

timeScale = 4.0

bulleted t s = Bulleted t $ fmap (" • " ++) s

tagAll symbol = fmap (<> Tagged symbol)
